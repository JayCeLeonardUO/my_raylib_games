/**
 * @file embed_binary.cpp
 * @brief CLI tool to embed binary files into C++ source code
 *
 * Usage: embed_binary <output.hpp> <file1> [file2] [file3] ...
 *
 * Generates a header file with:
 * - An enum BinaryId with entries for each file
 * - Byte arrays containing the file data
 * - A lookup function to get embedded data by ID
 */

#include <algorithm>
#include <cctype>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

namespace fs = std::filesystem;

struct FileEntry {
  std::string path;
  std::string name;       // sanitized name for C++ identifier
  std::string enum_name;  // UPPER_CASE for enum
  std::vector<uint8_t> data;
};

/// Convert filename to valid C++ identifier (lowercase with underscores)
std::string sanitize_name(const std::string& filename) {
  std::string result;
  for (char c : filename) {
    if (c == '.' || c == '-' || c == ' ') {
      result += '_';
    } else if (std::isalnum(c)) {
      result += static_cast<char>(std::tolower(c));
    }
  }
  // Ensure doesn't start with digit
  if (!result.empty() && std::isdigit(result[0])) {
    result = "_" + result;
  }
  return result;
}

/// Convert to UPPER_CASE for enum
std::string to_enum_name(const std::string& name) {
  std::string result;
  for (char c : name) {
    result += static_cast<char>(std::toupper(c));
  }
  return result;
}

/// Read entire file into byte vector
std::vector<uint8_t> read_file(const std::string& path) {
  std::ifstream file(path, std::ios::binary | std::ios::ate);
  if (!file) {
    std::cerr << "Error: Cannot open file: " << path << std::endl;
    return {};
  }

  std::streamsize size = file.tellg();
  file.seekg(0, std::ios::beg);

  std::vector<uint8_t> buffer(size);
  if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
    std::cerr << "Error: Cannot read file: " << path << std::endl;
    return {};
  }

  return buffer;
}

/// Generate the output header file
void generate_header(const std::string& output_path, const std::vector<FileEntry>& entries) {
  std::ofstream out(output_path);
  if (!out) {
    std::cerr << "Error: Cannot create output file: " << output_path << std::endl;
    return;
  }

  // Header guard and includes
  out << "/**\n";
  out << " * @file " << fs::path(output_path).filename().string() << "\n";
  out << " * @brief Auto-generated embedded binary data\n";
  out << " *\n";
  out << " * Generated by embed_binary tool. DO NOT EDIT MANUALLY.\n";
  out << " */\n\n";
  out << "#pragma once\n";
  out << "#include <cstddef>\n";
  out << "#include <cstdint>\n\n";

  // Enum definition
  out << "/// @brief Identifiers for embedded binary assets\n";
  out << "enum class BinaryId {\n";
  for (size_t i = 0; i < entries.size(); ++i) {
    out << "  " << entries[i].enum_name;
    if (i < entries.size() - 1) out << ",";
    out << "\n";
  }
  out << "};\n\n";

  // Struct for embedded data info
  out << "/// @brief Information about an embedded binary asset\n";
  out << "struct EmbeddedBinary {\n";
  out << "  const uint8_t* data;  ///< Pointer to binary data\n";
  out << "  size_t size;          ///< Size in bytes\n";
  out << "  const char* filename; ///< Original filename\n";
  out << "};\n\n";

  // Namespace for data arrays
  out << "namespace embedded_data {\n\n";

  for (const auto& entry : entries) {
    out << "/// @brief Embedded data for " << entry.path << " (" << entry.data.size()
        << " bytes)\n";
    out << "inline const uint8_t " << entry.name << "[] = {\n";

    // Write bytes in rows of 16
    for (size_t i = 0; i < entry.data.size(); ++i) {
      if (i % 16 == 0) out << "  ";
      out << "0x" << std::hex << std::setfill('0') << std::setw(2) << (int)entry.data[i];
      if (i < entry.data.size() - 1) out << ",";
      if (i % 16 == 15 || i == entry.data.size() - 1) out << "\n";
    }
    out << std::dec;  // Reset to decimal
    out << "};\n\n";
  }

  out << "}  // namespace embedded_data\n\n";

  // Lookup function
  out << "/**\n";
  out << " * @brief Get embedded binary data by ID\n";
  out << " * @param id The binary asset identifier\n";
  out << " * @return EmbeddedBinary struct with data pointer, size, and filename\n";
  out << " */\n";
  out << "inline EmbeddedBinary get_embedded_binary(BinaryId id) {\n";
  out << "  switch (id) {\n";
  for (const auto& entry : entries) {
    out << "    case BinaryId::" << entry.enum_name << ":\n";
    out << "      return {embedded_data::" << entry.name << ", sizeof(embedded_data::" << entry.name
        << "), \"" << fs::path(entry.path).filename().string() << "\"};\n";
  }
  out << "  }\n";
  out << "  return {nullptr, 0, nullptr};\n";
  out << "}\n";

  std::cout << "Generated: " << output_path << " with " << entries.size() << " embedded file(s)\n";
}

void print_usage(const char* program) {
  std::cerr << "Usage: " << program << " <output.hpp> <file1> [file2] [file3] ...\n";
  std::cerr << "\n";
  std::cerr << "Embeds binary files into a C++ header with:\n";
  std::cerr << "  - BinaryId enum for each file\n";
  std::cerr << "  - Byte arrays with file contents\n";
  std::cerr << "  - get_embedded_binary() lookup function\n";
  std::cerr << "\n";
  std::cerr << "Example:\n";
  std::cerr << "  " << program << " assets.hpp logo.png sound.wav font.ttf\n";
}

int main(int argc, char* argv[]) {
  if (argc < 3) {
    print_usage(argv[0]);
    return 1;
  }

  std::string output_path = argv[1];
  std::vector<FileEntry> entries;

  for (int i = 2; i < argc; ++i) {
    std::string path = argv[i];

    if (!fs::exists(path)) {
      std::cerr << "Error: File not found: " << path << std::endl;
      return 1;
    }

    FileEntry entry;
    entry.path = path;
    entry.name = sanitize_name(fs::path(path).filename().string());
    entry.enum_name = to_enum_name(entry.name);
    entry.data = read_file(path);

    if (entry.data.empty()) {
      std::cerr << "Warning: Skipping empty or unreadable file: " << path << std::endl;
      continue;
    }

    std::cout << "Embedding: " << path << " -> " << entry.enum_name << " (" << entry.data.size()
              << " bytes)\n";
    entries.push_back(std::move(entry));
  }

  if (entries.empty()) {
    std::cerr << "Error: No valid files to embed\n";
    return 1;
  }

  generate_header(output_path, entries);
  return 0;
}
